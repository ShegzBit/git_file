#!/usr/bin/python3
"""
Gets json file and reformat file
"""
import json
import os
import sys
import io
import requests
import shlex
from functools import reduce
import sys
import re

# Note Use of Global variable isTrunc, isRename and useName
# To track values across files though this is not good practice,
# it's used to prevent codebase wide refactoring that could lead to more bugs
# than the global variable could in the long run
# In case of errors always check to make sure you confirm the globals first
# see you future Feranmi :)


def url_validate(path):
    """
    Checks if path is a valid url
    """
    try:
        my_response = requests.get(path)
        my_response.raise_for_status()
    except requests.exceptions.HTTPError:
        print("===============================================")
        print("|  Sorry the link you provided doesn't exist  |")
        print("===============================================")
        exit(404)
    except requests.exceptions.MissingSchema:
        print("========================================")
        print("|  Sorry, you provided an invalid url  |")
        print("========================================")
        exit(1)
    return path

def is_github_file(path):
    """
    Checks if path is a URL to a valid file on a repo
    """
    # validate url
    url_validate(path)
    # confirm url could point at a github file to reduce unneccessary requests
    domains = path.split('/')
    if len(domains) < 6:
        print("==========================================================")
        print("|  Link doesn't doesn't point at a specific github file  |")
        print("==========================================================")
        exit(1)
    my_json = requests.get(path)
    try:
        return my_json.json()
    except json.JSONDecodeError as json_error:
        if "</html>" in my_json.text:
            print("========================================================")
            print("|  Link doesn't doesn't point at a file rather a page  |")
            print("========================================================")
            exit(1)

def handle_multiple_files(file_list, path):
    """
    Handles the cloning of multiple files
    """
    file_paths = list(map(lambda filename : path + '/' + filename, file_list))
    for path in file_paths:
        # if useName is not set then new dir was not created and the last
        # see git_files_in_dir for more info
        # two path in file link should be the filename
        # else the filename should be the useName i.e newly created dir
        # + filename i.e last path in link
        if not useName:
            filename = '/'.join(path.split('/')[-2:])
        else:
            filename = useName + '/' + path.split('/')[-1]
        git_file(path, isTrunc, filename)
     

def get_files_in_dir(path, json_response):
    """
    Gets the lists of files from dir if specified link points to a dir
    """
    dir_name = path.split('/')[-1]
    file_list = []

    content_dicts = json_response['payload']['tree']['items']

    """
    Each fileDict looks like
    {
       "name": "__pycache__",
        "path": "models/__pycache__",
        "contentType": "directory"
    },
    """
    file_dicts = filter((lambda file_dict : file_dict['contentType'] == 'file'), content_dicts)
    dir_dicts = list(filter((lambda file_dict : file_dict['contentType'] == 'directory'), content_dicts))

    file_list = reduce(lambda accumulator, file_obj: accumulator + [file_obj['path'].split('/')[-1]],
                       file_dicts, [])
    dir_list = reduce(lambda accumulator, file_obj: accumulator + [file_obj['path'].split('/')[-1]],
                       dir_dicts, [])

    dir_link_list = list(map(lambda dir: path + '/' + dir, dir_list))

    print(dir_link_list)

    if os.path.exists(dir_name):
        if not isRename:
            print('A file or Dir with the given name already exists but -r to rename dir was specified\nAborting...')
            exit(585)
    # if useName was set then user planned to rename check function get_args
    # for more info
    # else user is sure that he doesn't have that dir locally yet
    if not useName is None:
        os.mkdir(useName)
    else:
        os.mkdir(dir_name)

    pwd = os.getcwd()
    if len(dir_link_list) > 0:
        new_wd = dir_link_list[0].split('/')[-2]
        os.chdir(new_wd)
        if os.getcwd() == new_wd:
            print(f"Change to dir ==>> {new_wd}")
        else:
            print(f'Failed to switch to {new_wd}')
    for link in dir_link_list:
        print('Again')
        git_file(link, isTrunc, '/'.join(link.split('/')[-2:]))
    if not (os.getcwd() == pwd):
        os.chdir(pwd)
    handle_multiple_files(file_list, path)

def curl(path):
    """
    Gets rawlines of file
    """
    my_response = is_github_file(path)
    try:
        raw_lines = my_response['payload']['blob']['rawLines']
        return(raw_lines)
    except KeyError:
        if (my_response['payload']):
            dir_path = (my_response['payload'].get('path', "doesn't exist"))
        if dir_path == "doesn't exist":
            return
        get_files_in_dir(path, my_response)
        return {"isDir": True}

def git_file(path, isTrunc, filename):
    """
    Writes cloned file to the same file name in pwd
    """
    # get filename
    path_list = path.split('/')
    print(f"Filename from repo {path_list[-1]}")
    print(path_list[-1])
    if filename == "":
        filename = path_list[-1]
    print(f"Local filename {filename}")

    file_lines = curl(path)
    if type(file_lines) == dict and file_lines["isDir"]:
        return

    if os.path.exists(filename):
        if not isTrunc:
            print('File exists but truncate on file exist option -t was not specified')
            exit(444)
    if file_lines is None:
        print("================================================================")
        print("|  Sorry, This program does not support raw files or executable|")
        print("================================================================")
        print("If you wish to add this functionality or contribute in anyway,\nhead to the repo and get my contact info from the readme :) ")
        return(454)
    with open(filename, 'w', encoding='utf-8') as f:
            for line in file_lines:
                f.write(line + '\n')

def get_args(args):
    """
    Get's arguments from file
    """
    arguments = shlex.split(args)
    valid_args = ['-t', '-r']
    path = ""
    filename=""
    global isTrunc
    global isRename
    global useName
    isTrunc = False
    isRename = False
    useName = None
    for counts, x in enumerate(arguments):
        # check for arguments
        if x.startswith('-'):
            if x not in valid_args:
                print("invalid argument passed to git_file\nUsage: git_file <options> <arguments>")
                exit(414)
            # handle for truncate on file exists argument
            elif x == "-t":
                isTrunc = True
            # handle for rename file argument
            if x == "-r":
                isRename = True
                if len(arguments) <= counts + 1:
                    print("File Name missing\nUsage: git_file -r <filename> <other arguments>")
                    exit(424)
                elif (not arguments[counts + 1].startswith("https://") and
                      arguments[counts + 1] not in valid_args):
                    useName = filename = arguments[counts + 1]
        if x.startswith("http"):
            path = x
    if path == "":
        print("valid URL missing from arguments\nUsage: git_file <options> <arguments>")
        exit(434)
    print(path + "...")
    git_file(path, isTrunc, filename)

def concat_args(lists):
    """
    concat arguments to their appropraite options
    """
    # link -r name -t link
    main_list = []
    for count, arg in enumerate(lists):
        i = count + 1
        if arg.startswith("https"):
            while i < len(lists):
                if lists[i].startswith("https"):
                    break
                arg = f"{arg} {lists[i]}"
                i += 1
            main_list.append(arg)
    return main_list

def handle_M_option(lists):
    """
    Handles -m option in argument to program
    """
    return_list = []
    length = len(lists)
    m_option = False
    for count, arg in enumerate(lists):
        if arg =="-m":
            m_option = True
            default_link = lists[count - 1]
            continue
        if m_option:
            arg = f"{default_link}/{arg}"
            return_list.append(arg)
    if default_link in return_list:
        return_list.remove(default_link)
    return return_list

def abstract_handler_M(args):
    """
    breaks the concated args into lists again so it's suitable for operation
    of handler_M_option
    concated args will be a list similar to
    [https://github.com/ShegzBit/AirBnB_clone/blob/main/models -m file1 file2 file3,
    https://github.com/ShegzBit/AirBnB_clone/blob/main/models -m file1 file2 file3,
    https://github.com/ShegzBit/AirBnB_clone/blob/main/models -m file1 file2 file3]
    This function makes it work on each one like a separate command to the program
    """
    working_list = []
    for arg in args:
        if "-m" in arg:
            new_list = arg.split(" ")
            working_list.extend(handle_M_option(new_list))
        else:
            working_list.append(arg)
    for arg in working_list:
        get_args(arg)
                

def main(args):
    new_args = concat_args(args)
    abstract_handler_M(new_args)


if __name__ == '__main__':
    args = sys.argv[1:]
    main(args)
